print.fun('sigmoid')
print.fun('stable.softmax')
print.fun('sigmoid')
print.fun('relu')
print.fun('tanh')
print.fun('dsigmoid')
print.fun('drelu')
print.fun('dtanh')
# check sigmoid
d=runif(10)
round( (sigmoid(d+10^-8)-sigmoid(d-10^-8))/(2*10^-8)-dsigmoid(d) , 7 )
#check relu
(relu(d+10^-8)-relu(d-10^-8))/(2*10^-8)-drelu(d)
#check tanh
(tanh(d+10^-8)-tanh(d-10^-8))/(2*10^-8)-dtanh(d)
print.fun('fwd.prop')
print.fun('bk.prop')
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
wb <- init.wgt( 1 , 2 , x )
fp <- fwd.prop( x , 1, wb$W, wb$B, activation = tanh, output = Identity )
bp <- bk.prop( xx, y, 4, wb$W, wb$B , Activation = tanh, derivative = dtanh,
Output = Sigmoid )
bk.prop
bp <- bk.prop( xx, y, 4, wb$W, wb$B , Activation = tanh, derivative = dtanh)
bp <- bk.prop( x, y, 1, wb$W, wb$B , Activation = tanh, derivative = dtanh)
bp
bk.prop
bp <- bk.prop( x, y, 1, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp
hl <- 1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Identity )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] )
bp
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1 ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] )
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1 ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] )
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1 ]]
bp$dB
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] )
bp$dB
num.gradient
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1 ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1 ]]
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
bp$dB[[ hl + 1 ]]; bp$dZ[[ hl + 1   ]]
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
bp$dB[[ hl + 1 ]]; bp
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
spirals  <- mlbench.spirals(75,1.5,.07)
fwd.prop
x <- t(spirals$x)
y <- spirals$classes - 1
y <- spirals$classes; y <- as.numeric(y)-1
y
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
spirals  <- mlbench.spirals(75,1.5,.07)
x <- t(spirals$x)
y <- spirals$classes; y <- as.numeric(y)-1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
num.gradient
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
n1=50; mu1=c(.5,.5);  cov1=diag(.2,2)
n2=40; mu2=c(1.5,1.5);cov2=diag(.1,2)
n3=30; mu3=c(1.5,0);  cov3=diag(.1,2)
mean.cov.list=list()
mean.cov.list[[1]]=list(n=50, mu=c(.5,.5),  cov=diag(.2,2))
mean.cov.list[[2]]=list(n=40, mu=c(1.5,1.5),cov=diag(.1,2))
mean.cov.list[[3]]=list(n=30, mu=c(1.5,0),  cov=diag(.1,2))
#c(X,y) %<-% generate.gaussian.data.class3(n1,mu1,cov1,n2,mu2,cov2,n3,mu3,cov3)
c(x,y) %<-% gen.gaussian.data.2d(mean.cov.list)
plot(x[1,],x[2,],pch=1,col=y+1,lwd=2,cex=1)
x
num.gradient
nnet1.fit
setwd("G:\\math\\514")
source('hw5_514.R')
library(mlbench)
data=mlbench.spirals(75,1.5,.07)
plot(data)
X=t(data$x)
Y=matrix(as.integer(data$classes)-1,nrow=1)
print.fun('cost.squared.error')
print.fun('cost.negll')
print.fun('cost.cross.entropy')
print.fun('identity')
print.fun('sigmoid')
print.fun('stable.softmax')
print.fun('sigmoid')
print.fun('relu')
print.fun('tanh')
print.fun('dsigmoid')
print.fun('drelu')
print.fun('dtanh')
# check sigmoid
d=runif(10)
round( (sigmoid(d+10^-8)-sigmoid(d-10^-8))/(2*10^-8)-dsigmoid(d) , 7 )
#check relu
(relu(d+10^-8)-relu(d-10^-8))/(2*10^-8)-drelu(d)
#check tanh
(tanh(d+10^-8)-tanh(d-10^-8))/(2*10^-8)-dtanh(d)
print.fun('fwd.prop')
print.fun('bk.prop')
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
hl <- 1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Identity )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
spirals  <- mlbench.spirals(75,1.5,.07)
x <- t(spirals$x)
y <- spirals$classes; y <- as.numeric(y)-1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
n1=50; mu1=c(.5,.5);  cov1=diag(.2,2)
n2=40; mu2=c(1.5,1.5);cov2=diag(.1,2)
n3=30; mu3=c(1.5,0);  cov3=diag(.1,2)
mean.cov.list=list()
mean.cov.list[[1]]=list(n=50, mu=c(.5,.5),  cov=diag(.2,2))
mean.cov.list[[2]]=list(n=40, mu=c(1.5,1.5),cov=diag(.1,2))
mean.cov.list[[3]]=list(n=30, mu=c(1.5,0),  cov=diag(.1,2))
#c(X,y) %<-% generate.gaussian.data.class3(n1,mu1,cov1,n2,mu2,cov2,n3,mu3,cov3)
c(x,y) %<-% gen.gaussian.data.2d(mean.cov.list)
plot(x[1,],x[2,],pch=1,col=y+1,lwd=2,cex=1)
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
print.fun('init.wgts')
# call init.wgts - data samples are arranged by column
model=init.wgts(n.in=nrow(X),n.hid=1,n.out=nrow(Y))
print.fun('nnet1.fit')
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
np=length(x)
x.set=c(x)
y.set=c(y)
degree=15
lm.fit = lm(y ~ poly(x,degree,raw=FALSE), data=data.frame(y=y.set,x=x.set))
y = predict.lm(lm.fit,data.frame(x=xgrid))
#plot(xgrid,y,type="l",col="black",lwd=2)
#legend("topright", legend = c(num_hidden,paste("degree=",degree)), col = colors,lwd=2 )
nnet1.fit( x, y, 1 , 2 , 150000, 1, Activation = tanh, Output = Identity )
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
x,y,xgrid,ygrid
x
nnet1.fit( x, y, 1 , 2 , 150000, 1, Activation = tanh, Output = Identity )
y
y
x
nnet1.fit
setwd("G:\\math\\514")
source('hw5_514.R')
library(mlbench)
spirals=mlbench.spirals(75,1.5,.07)
plot(spirals)
spiralsx=t(data$spirals)
spirals
t(spirals$x)
y=matrix(as.integer(data$classes)-1,nrow=1)
setwd("G:\\math\\514")
source('hw5_514.R')
library(mlbench)
spirals=mlbench.spirals(75,1.5,.07)
plot(spirals)
spiralsx=t(spirals$x)
y=matrix(as.integer(spiralsx$classes)-1,nrow=1)
spiralsx$classes
install.packages("zeallot")
require("zeallot")
setwd("G:\\math\\514")
source('hw5_514.R')
library(mlbench)
spirals=mlbench.spirals(75,1.5,.07)
plot(spirals)
spiralsx=t(spirals$x)
y=matrix(as.integer(spirals$classes)-1,nrow=1)
print.fun('cost.squared.error')
print.fun('cost.negll')
print.fun('cost.cross.entropy')
print.fun('identity')
print.fun('sigmoid')
print.fun('stable.softmax')
print.fun('sigmoid')
print.fun('relu')
print.fun('tanh')
print.fun('dsigmoid')
print.fun('drelu')
print.fun('dtanh')
# check sigmoid
d=runif(10)
round( (sigmoid(d+10^-8)-sigmoid(d-10^-8))/(2*10^-8)-dsigmoid(d) , 7 )
#check relu
(relu(d+10^-8)-relu(d-10^-8))/(2*10^-8)-drelu(d)
#check tanh
(tanh(d+10^-8)-tanh(d-10^-8))/(2*10^-8)-dtanh(d)
print.fun('fwd.prop')
print.fun('bk.prop')
library(zeallot)
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
hl <- 1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Identity )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost = cost.squared.error )
spirals  <- mlbench.spirals(75,1.5,.07)
x <- t(spirals$x)
y <- spirals$classes; y <- as.numeric(y)-1
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
n1=50; mu1=c(.5,.5);  cov1=diag(.2,2)
n2=40; mu2=c(1.5,1.5);cov2=diag(.1,2)
n3=30; mu3=c(1.5,0);  cov3=diag(.1,2)
mean.cov.list=list()
mean.cov.list[[1]]=list(n=50, mu=c(.5,.5),  cov=diag(.2,2))
mean.cov.list[[2]]=list(n=40, mu=c(1.5,1.5),cov=diag(.1,2))
mean.cov.list[[3]]=list(n=30, mu=c(1.5,0),  cov=diag(.1,2))
c(x,y) %<-% gen.gaussian.data.2d(mean.cov.list)
wb <- init.wgt( hl , 2 , x )
fp <- fwd.prop( x , hl, wb$W, wb$B, activation = tanh, output = Sigmoid )
bp <- bk.prop( x, y, hl, wb$W, wb$B , fp$Z , fp$A, Activation = tanh, derivative = dtanh)
bp$dB[[ hl + 1 ]]; bp$dW[[ hl + 1   ]]
num.gradient( fp$A[[ hl  ]] , y ,  ( wb$B[[hl +1]] ) , wb$W[[hl +1]] , cost =   cost.negll )
print.fun('init.wgts')
# call init.wgts - data samples are arranged by column
#model=init.wgts(n.in=nrow(X),n.hid=1,n.out=nrow(Y))
print.fun('nnet1.fit')
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
np=length(x)
x.set=c(x)
y.set=c(y)
degree=15
lm.fit = lm(y ~ poly(x,degree,raw=FALSE), data=data.frame(y=y.set,x=x.set))
y = predict.lm(lm.fit,data.frame(x=xgrid))
#plot(xgrid,y,type="l",col="black",lwd=2)
#legend("topright", legend = c(num_hidden,paste("degree=",degree)), col = colors,lwd=2 )
nnet1.fit( x, y, 1 , 2 , 150000, 1, Activation = tanh, Output = Identity )
y
c(x,y,xgrid,ygrid) %<-% data.lawrence.giles(12345)
y
nnet1.fit
unlink('G:/math/514/hw5_514_cache', recursive = TRUE)
P <- .995
options(width = 1000)
setwd("G:/bs/")
bsno <- 35783
source("BSv3.R")
blerg <- do.call(rbind, stratum );nrow(blerg)
datz <- rbind(datP , datN); nrow(datz)
all( (datz$ID %in% blerg$ID) == T)
all( (blerg$ID %in% datz$ID) == T)
sum( datz$CSR_PRVDD  ) ==sum( blerg$CSR_PRVDD )
options(scipen=999)
DFa <- data.frame( sapply(stratum,function(X) min(X$CSR_PRVDD))  ,
sapply(stratum,function(X) max(X$CSR_PRVDD))   )
DFa[,2] <- apply(DFa,1,function(X)    paste0( "(" ,round(X[1],2),", ",round(X[2],2),")" ) )
DFa[,1] <-   sapply(stratum,function(X) max(X$Stratum) )
colnames(DFa) <- c("Stratum" , "Bounds")
DFa$Variant <- sapply(stratum, function(X) X$Variant[1] )
DFa$payment <- sapply(stratum, function(X) X$payment[1] )
DFa$TotAmnt <- sapply(stratum, function(X) X$AMOUNT[1] )
DFa$N_h <- sapply(stratum,nrow)
DFa$MINn <- 0;
for( i in 1:length(censam)){ 	if(censam[i] == "C"){
DFa$MINn[i] <- DFa$N_h[i]}else{DFa$MINn[i] <- 30} }
DFa$ss_err <- round( sapply(stratum , function(X) var(X$error )   ), 2 )
DFa$s_err <- round( sqrt( DFa$ss_err  ) ,2  )
DFa[is.na(DFa)] <- 0
Nh <- DFa$N_h
N <- sum( DFa$N_h )
print(DFa, row.names = F)
DF <- DFa[ which(DFa$N_h != DFa$MINn) , ]
DF$mean_err <- round( sapply(stratum[DF$Stratum], function(X) mean(X$error )   ), 4 )
DF$s_err <- round( sapply(stratum[DF$Stratum], function(X) sd(X$error )   ), 4 )
N <- DF$N_h
print(DF[,-c((ncol(DF)-1),ncol(DF))], row.names = F)
print( head(stratum[[2]])[,-c(4,(ncol(DF)-1),ncol(DF))], row.names = F)
numerator <- DF$N_h * DF$s_err
EO<-list()
for (i in 1:nrow(DF)){ EO[[i]]<- sqrt(seq(30,(N[i]-1),1)* (seq(30,(N[i ]-1),1)+1))}
for (i in 1:nrow(DF)){	EO[[i]]<-	numerator[i]/EO[[i]]} # NS/sqrt(n*n+1)
for (i in 1:length(numerator)) { EO[[i]]<-data.frame(EO[[i]],rep( DF$Stratum[i],length(
EO[[i]]))) }		#this convert into DF and put statum ID
EO<-do.call(rbind.data.frame, EO)
colnames(EO)<-c("PV","Stratum");
EO<-EO[order(-EO$PV),]
head(EO)
matx<-matrix(NA,nrow(EO),2)
matx[,1]<-EO$PV; matx[,2]<-EO$Stratum;
matx<- cbind(matx,matrix(0,nrow(EO),nrow(DFa) ),0,0)
colnames(matx) <- c("PV","Stratum", paste0("h_",DFa$Stratum), "n" , "Sd" )
######
matx <- rbind( matx[1,]*0, matx )
N <- DFa$N_h #nrow(matx)
matx[ 1 ,3:(ncol(matx) - 2)  ] <- DFa$MINn
matx[ 1 ,(ncol(matx) - 1) ] <- sum(matx[ 1 ,3:(ncol(matx) - 2)  ])
matx[ 1 ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[1,3:(ncol(matx)-2)])*
DFa$ss_err)/  (matx[1,3:(ncol(matx)-2)]) ) )
for (i in 2:10){
matx[i, 3:(2+nrow(DFa)) ] <- matx[i-1, 3:(2+nrow(DFa)) ]
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] <-
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] + 1
matx[i, (ncol(matx)-1)] <- sum(matx[i, 3:(ncol(matx)-2)] )
}
head(matx)
i = 2
matx[i-1, 3:(2+nrow(DFa)) ]
matx
head(matx)
matx<-matrix(NA,nrow(EO),2)
matx[,1]<-EO$PV; matx[,2]<-EO$Stratum;
matx<- cbind(matx,matrix(0,nrow(EO),nrow(DFa) ),0,0)
colnames(matx) <- c("PV","Stratum", paste0("h_",DFa$Stratum), "n" , "Sd" )
matx <- rbind( matx[1,]*0, matx )
N <- DFa$N_h #nrow(matx)
matx[ 1 ,3:(ncol(matx) - 2)  ] <- DFa$MINn
matx[ 1 ,(ncol(matx) - 1) ] <- sum(matx[ 1 ,3:(ncol(matx) - 2)  ])
matx[ 1 ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[1,3:(ncol(matx)-2)])*
DFa$ss_err)/  (matx[1,3:(ncol(matx)-2)]) ) )
round(matx[ 1, ]  ,2)
as.data.frame( round(matx[ 1, ]  ,2) )
as.data.frame( round(t(matx[ 1, ]  ,2) ))
as.data.frame( round(matx[ 1, ]  ,2) )
t( as.data.frame( round(matx[ 1, ]  ,2) ) )
datmat <- t( as.data.frame( round(matx[ 1, ]  ,2) ) )
rownames(datmat) <- NULL
print( datmat, row.names = F )
beep("mario")
require(beepr)
beep("mario")
print( head(round(matx,2)) , row.names = F )
print( as.data.frame( head(round(matx,2)) ) , row.names = F )
unlink('G:/bs/HIOS-11512_cache', recursive = TRUE)
unlink('G:/bs/HIOS-11512_cache', recursive = TRUE)
P <- .995
options(width = 1000)
setwd("G:/bs/")
bsno <- 11512
source("BSv3.R")
require(beepr)
blerg <- do.call(rbind, stratum );nrow(blerg)
datz <- rbind(datP , datN); nrow(datz)
all( (datz$ID %in% blerg$ID) == T)
all( (blerg$ID %in% datz$ID) == T)
sum( datz$CSR_PRVDD  ) ==sum( blerg$CSR_PRVDD )
#beep("mario")
options(scipen=999)
DFa <- data.frame( sapply(stratum,function(X) min(X$CSR_PRVDD))  ,
sapply(stratum,function(X) max(X$CSR_PRVDD))   )
DFa[,2] <- apply(DFa,1,function(X)    paste0( "(" ,round(X[1],2),", ",round(X[2],2),")" ) )
DFa[,1] <-   sapply(stratum,function(X) max(X$Stratum) )
colnames(DFa) <- c("Stratum" , "Bounds")
DFa$Variant <- sapply(stratum, function(X) X$Variant[1] )
DFa$payment <- sapply(stratum, function(X) X$payment[1] )
DFa$TotAmnt <- sapply(stratum, function(X) X$AMOUNT[1] )
DFa$N_h <- sapply(stratum,nrow)
DFa$MINn <- 0;
for( i in 1:length(censam)){ 	if(censam[i] == "C"){
DFa$MINn[i] <- DFa$N_h[i]}else{DFa$MINn[i] <- 30} }
DFa$ss_err <- round( sapply(stratum , function(X) var(X$error )   ), 2 )
DFa$s_err <- round( sqrt( DFa$ss_err  ) ,2  )
DFa[is.na(DFa)] <- 0
Nh <- DFa$N_h
N <- sum( DFa$N_h )
print(DFa, row.names = F)
DF <- DFa[ which(DFa$N_h != DFa$MINn) , ]
DF$mean_err <- round( sapply(stratum[DF$Stratum], function(X) mean(X$error )   ), 4 )
DF$s_err <- round( sapply(stratum[DF$Stratum], function(X) sd(X$error )   ), 4 )
N <- DF$N_h
print(DF[,-c((ncol(DF)-1),ncol(DF))], row.names = F)
numerator <- DF$N_h * DF$s_err
EO<-list()
for (i in 1:nrow(DF)){ EO[[i]]<- sqrt(seq(30,(N[i]-1),1)* (seq(30,(N[i ]-1),1)+1))}
for (i in 1:nrow(DF)){	EO[[i]]<-	numerator[i]/EO[[i]]} # NS/sqrt(n*n+1)
for (i in 1:length(numerator)) { EO[[i]]<-data.frame(EO[[i]],rep( DF$Stratum[i],length(
EO[[i]]))) }		#this convert into DF and put statum ID
EO<-do.call(rbind.data.frame, EO)
colnames(EO)<-c("PV","Stratum");
EO<-EO[order(-EO$PV),]
head(EO)
matx<-matrix(NA,nrow(EO),2)
matx[,1]<-EO$PV; matx[,2]<-EO$Stratum;
matx<- cbind(matx,matrix(0,nrow(EO),nrow(DFa) ),0,0)
colnames(matx) <- c("PV","Stratum", paste0("h_",DFa$Stratum), "n" , "Sd" )
######
matx <- rbind( matx[1,]*0, matx )
N <- DFa$N_h #nrow(matx)
matx[ 1 ,3:(ncol(matx) - 2)  ] <- DFa$MINn
matx[ 1 ,(ncol(matx) - 1) ] <- sum(matx[ 1 ,3:(ncol(matx) - 2)  ])
matx[ 1 ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[1,3:(ncol(matx)-2)])*
DFa$ss_err)/  (matx[1,3:(ncol(matx)-2)]) ) )
for (i in 2:10){
matx[i, 3:(2+nrow(DFa)) ] <- matx[i-1, 3:(2+nrow(DFa)) ]
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] <-
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] + 1
matx[i, (ncol(matx)-1)] <- sum(matx[i, 3:(ncol(matx)-2)] )
matx[i ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[i,3:
(ncol(matx)-2)])* DFa$ss_err)/  (matx[i,3:(ncol(matx)-2)]) ) )
}
matx[nrow(matx),3:(ncol(matx)-2)] <- DFa$N_h
matx[nrow(matx),  (ncol(matx)-1)] <- sum(matx[nrow(matx),3:(ncol(matx)-2)] )
matx[nrow(matx) ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[nrow(matx),3:
(ncol(matx)-2)])* DFa$ss_err)/  (matx[nrow(matx),3:(ncol(matx)-2)]) ) )
for( i in (nrow(matx)-1):(nrow(matx)-10) ){
matx[i,3:(ncol(matx)-2)] <-  matx[i+1,3:(ncol(matx)-2)]
matx[i, 2 +  matx[i+1 ,2]  ] <-  matx[i, 2 +  matx[i+1 ,2]  ] - 1
matx[i,  (ncol(matx)-1)] <- sum(matx[i,3:(ncol(matx)-2)] )
matx[i ,(ncol(matx)) ] <- sqrt( sum((N*(N-matx[i,3:
(ncol(matx)-2)])* DFa$ss_err)/  (matx[i,3:(ncol(matx)-2)]) ) )
}
#head(matx);tail(matx)
#sum(dat$CSR_PRVDD)
error <- sum(dat$CSR_PRVDD)*.0832 ;
#c( error - error *.1, error + error *.1 )
target <- error *.1 /  qnorm(.95)
for (i in 11:nrow(matx)){
if( matx[i-1, ncol(matx)] < target ){break}
matx[i, 3:(2+nrow(DFa)) ] <- matx[i-1, 3:(2+nrow(DFa)) ]
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] <-
matx[ i , which( colnames(matx) == paste0("h_", matx[i, 2] ) )] + 1
matx[i, (ncol(matx)-1)] <- sum(matx[i, 3:(ncol(matx)-2)] )
}
##
print( as.data.frame( head(round(matx,2)) ) , row.names = F )
sum(dat$CSR_PRVDD)
TOTerror <- sum(dat$CSR_PRVDD)*.0832 ; TOTerror
TOTerror *.1; t1 <- TOTerror *.1
target <- TOTerror *.1 /  qnorm(.95); target
matx<-as.data.frame(matx)
DFa$s_err <- round(sqrt(as.numeric(DFa$ss_err)),2)
blergs <- sapply(stratum, function(X) sd(X$CSR_PRVDD ))
blergs[is.na(blergs)] <- 0
DFa$sdTA <- round(blergs,2)
#
DFa <- DFa[, c(1:5,ncol(DFa) , 6:(ncol(DFa)-1)) ]
DFa$n <-as.numeric( matx[ tail( which(matx$Sd >  target ) , 1 ) , 3:(ncol(matx)-2)] )
if( nrow( matx[ tail( which(matx$Sd >  target ) , 2 ) , 3:(ncol(matx)-0)] 	) == 0 ) { DFa$n <- DFa$MINn }
print(rbind(DFa,c("Totals", "-" , "-" , "", sum(as.numeric(DFa$TotAmnt)), sum(as.numeric(DFa$sdTA)), sum(DFa$N_h),
sum(DFa$MINn), sum(DFa$ss_err) , sum(DFa$s_err) ,sum(DFa$n)   )), row.names = F )
setwd("G:\\math\\514")
source("hw5_514.r")
spirals <- spiralpred <- mlbench.spirals(75,1.5,.07)
y <- as.numeric(spirals$classes) - 1
x <- t(spirals$x )
spirals <- spiralpred <- mlbench.spirals(75,1.5,.07)
y <- as.numeric(spirals$classes) - 1
x <- t(spirals$x )
X <- x; Y <- y; HL <- 1; nodes <- 5; batches <- 2; LR = 1.5
WB <- init.wgt( HL, nodes , X)
W <- WB$W; B <- WB$B
Acts <- as.character(substitute(Activation ) )
Outpt <- as.character(substitute( Output ) )
if( Acts == "relu" ){ Derivative <- drelu
} else if ( Acts == "tanh" ) {   Derivative <- dtanh
} else { Derivative <- dsigmoid }
C1 <- 0; Costs <- list()
M <- length(as.vector(Y))
C1 <- 0; Costs <- list()
M <- length(as.vector(Y))
ST <-system.time(
for( i in 1:3) {
for( j in 1:length(Xt) ){
FP  <- fwd.prop( X , HL , W, B, sigmoid, Sigmoid)
C2  <- Cost( Y , FP$A[[ HL+1 ]], "Sigmoid")
BP <-  bk.prop(X, Y, HL , W, B, FP$Z, FP$A ,
sigmoid, Sigmoid )
for( j in 1:(HL + 1)  ){
B[[j]] <- B[[j]] - (LR  )* BP$dB[[j]]
W[[j]] <- W[[j]] - (LR ) * BP$dW[[j]] }
}} )
ST <-system.time(
for( j in 1:15 ){
FP  <- fwd.prop( X , HL , W, B, sigmoid, Sigmoid)
C2  <- Cost( Y , FP$A[[ HL+1 ]], "Sigmoid")
BP <-  bk.prop(X, Y, HL , W, B, FP$Z, FP$A ,
sigmoid, Sigmoid )
for( j in 1:(HL + 1)  ){
B[[j]] <- B[[j]] - (LR  )* BP$dB[[j]]
W[[j]] <- W[[j]] - (LR ) * BP$dW[[j]] }
}  )
B
W
dim(x)
devtools::install_github("rstudio/keras")
library(keras)
install_keras(tensorflow = "gpu",method = "conda")
